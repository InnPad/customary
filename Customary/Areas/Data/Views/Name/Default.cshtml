@using Custom.Areas.Metadata.Models
@using Custom.Data.Metadata
@{
    Layout = "~/Areas/Data/Views/Shared/_Layout.cshtml";
}

<style>
    .x-tab-bar-default-top {
        background-color: #dfe8f5;
        background-image: none; /*-webkit-linear-gradient(top,#dde8f5,#cbdbef);*/
    }

    /* Replaces default tree node yellow 
       folder icon with an OSX style one */
    /*#containerTreePanel .x-tree-icon-parent {
        background-image: url("images/icon-fldr-default-closed.png");
    }*/

    /* This is the open state of the yellow
       folder icon. */
    /*#containerTreePanel .x-grid-tree-node-expanded .x-tree-icon-parent {
        background-image: url("images/icon-fldr-default-closed.png");
        padding-top: 1px;
    }*/

    /* Replaces the default tree node leaf
       icon with Hub List list icon */
    /*#containerTreePanel .x-tree-icon-leaf {
        background-image: url("images/icon-sdbar-list.png");
        width: 14px;
    }*/

    .x-tree-icon.x-tree-icon-leaf.x-tree-icon-model {
        background-image: url("@Url.Content("~/Images/Metadata/model.png")");
    }

    .x-tree-icon.x-tree-icon-leaf.x-tree-icon-value {
        background-image: url("@Url.Content("~/Images/Metadata/value.png")");
    }

    .x-tree-icon.x-tree-icon-leaf.x-tree-icon-enum {
        background-image: url("@Url.Content("~/Images/Metadata/enum.png")");
    }

    .x-tree-icon.x-tree-icon-leaf.x-tree-icon-unit {
        background-image: url("@Url.Content("~/Images/Metadata/unit.png")");
    }

</style>

<script type="text/javascript">
    Ext.Loader.setPath('Ext', '@Url.Absolute("/Scripts/Ext")');
</script>

<script type="text/javascript">
    var frameStyle = 'background-color:#dfe8f5;';
</script>

<script type="text/javascript">
    Ext.define('Customary.view.Directory', {
        extend: 'Ext.custom.data.Directory'
    });
</script>

<script type="text/javascript">
    Ext.define('Customary.view.Drop', {
        extend: 'Ext.custom.Droplet'
    });
</script>

<script type="text/javascript">
    Ext.define('Customary.controller.Drops', {
        extend: 'Ext.app.Controller',
        //views: ['posts.List', 'posts.Edit'],

        //the rest of the Controller here

        init: function () {
            this.control({
                'viewport > panel': {
                    render: this.onPanelRendered
                }
            });
        },

        onPanelRendered: function () {
            console.log('The panel was rendered');
        }
    });
</script>

<script type="text/javascript">
    Ext.define('Custom.app.Application', function () {

        var _baseUrl = 'http://data.customary.com';

        var guidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;

        var $metadata = {
        };

        function asyncMetadata(typeName, callback) {

            var $m = Custom.app.Application.findMetadata(typeName);

            if ($m !== null && typeof $m === 'object') {
                callback($m);
            }
            else {

                var jsonData = {
                    requires: requires(typeName)
                };

                Ext.Ajax.request({
                    url: _baseUrl + '/Data/' + typeName + '/$metadata',
                    method: 'POST',
                    jsonData: jsonData,
                    /*params: {
                        id: '00000000-0000-0000-0000-000000000001'
                    },*/
                    success: function (response, options) {
                        var text = response.responseText;
                        var json = Ext.JSON.decode(text, true);
                        if (json == null || typeof json !== 'object') {
                            alert(text);
                        }
                        else if (json.success === true && typeof json.data === 'object') {

                            mergeMetadata(json.data);

                            $m = Custom.app.Application.findMetadata(typeName);

                            if ($m !== null && typeof $m === 'object') {
                                callback.call(this, $m);
                            }

                        } else if (typeof json.message === 'string') {
                            alert(json.message);
                        }
                    },
                    failure: function (response, options) {
                    },
                    scope: this
                });
            }
        }

        function asyncModel(typeName, callback) {

            var modelName = makeModelName(typeName);

            var model = Ext.ModelManager.getModel(modelName);

            if (model !== null && typeof model === 'function') {
                callback(modelName, model);
                return;
            }

            this.asyncMetadata(typeName, function ($m) {

                model = Custom.app.Application.defineModel(modelName, $m);

                callback(modelName, model);
            });
        }

        function collectFields($m, $fields) {

            if ($m === null || typeof $m !== 'object') {
                return $fields;
            }

            if (typeof $m.$base === 'string') {
                collectFields(Custom.app.Application.findMetadata($m.$base), $fields);
            }

            if ($m !== null && typeof $m.$fields === 'object' && $m.$fields.length > 0) {
                $fields.push.apply($fields, $m.$fields);
            }

            return $fields;
        }

        function configGrid($fields, columns, config) {

            if (Object.prototype.toString.call(columns) === '[object Array]' && columns.length > 0) {
                //if (typeof columns === 'object' && columns !== null && typeof columns.length === 'int' && columns.length > 0) {
                var hash = {};
                for (var i = 0; i < $fields.length; i++) {
                    var $field = $fields[i];
                    hash[$field.$name] = $field;
                }
                $fields = [];
                for (var i = 0; i < columns.length; i++) {
                    var $field = hash[columns[i]];
                    if (typeof $field === 'object' && $field != null) {
                        $fields.push($field);
                    }
                }
            }

            var items = [];

            for (var i = 0; i < $fields.length; i++) {

                var $field = $fields[i];
                var text = Ext.custom.Adapter.toString($field.$title, $field.$name);
                var role = Custom.app.Application.splitRole($field.$role);

                if ($field.$category === 'model') {
                    switch ($field.$prototype) {
                        case 'Text':
                            items.push({
                                dataIndex: '$' + $field.$name,
                                flex: 2,
                                header: text,
                                /*renderer: function (value) {
                                    return Ext.custom.Adapter.toString(value);
                                },*/
                                text: text
                            });
                            break;
                    }
                    continue;
                }

                var column = {
                    editor: {
                        xtype: 'textfield',
                        allowBlank: !role.required
                    },
                    dataIndex: $field.$name,
                    flex: 1,
                    header: text,
                    text: text
                };

                var editor = {};

                switch ($field.$type) {

                    case 'boolean':
                        column.xtype = 'booleancolumn';
                        break;

                    case 'date':
                        column.xtype = 'datecolumn';
                        column.format = 'Y-m-d';
                        break;

                    case 'number':
                        column.xtype = 'numbercolumn';
                        //column.editor.format = '0.00';
                        break;

                    case 'string':
                        column.editor.xtype = 'textfield';
                        break;
                }

                switch ($field.$prototype) {
                    case 'Boolean':
                        Ext.merge(column, {
                            editor: {
                            }
                        });
                        break;

                    case 'Email':
                        editor = { vtype: 'email' };
                        break;

                    case 'Password':
                        break;

                    case 'Date':
                        Ext.merge(column, {
                            editor: {
                                xtype: 'checkbox'
                            }
                        });
                        break;
                }

                items.push(column);
            }

            var selModel = Ext.create("Ext.selection.RowModel", {
                selType: "rowmodel",
                listeners: {
                    selectionchange: {
                        fn: function (selModel, selections) {
                            //this.onSelectionChange(selModel, selections, "master")
                        },
                        scope: this
                    }
                }
            });

            Ext.merge(config, {
                selModel: selModel,
                //plugins: [this.rowEditing],
                columns: {
                    items: items
                },
                xtype: 'grid'
            });

            return config;
        }

        function defineModel(name, $m) {

            var extend = 'Ext.data.Model';

            if (typeof $m.$extend === 'string') {
                var extendModel = this.findModel($m.$extend);
                //extend = makeModelName($m.$extend);
            }

            var config = {
                extend: extend,
                idProperty: 'Id',
                fields: [],
                associations: [],
                validations: []
            };

            if (typeof $m.$belongsTo === 'string') {
                config['belongsTo'] = makeModelName($m.$belongsTo);
                /*var belongsTo = this.findModel($m.$belongsTo);
                if (belongsTo) {
                    config['belongsTo'] = belongsTo.modelName;
                }*/
            }

            var $fields = Custom.app.Application.collectFields($m, []);

            var types = Ext.data.Types; // allow shorthand type access

            for (var i = 0; i < $fields.length; i++) {
                var $field = $fields[i];
                var role = splitRole($field.$role);
                var field = { name: $field.$name };

                if (role.required) {
                    field.useNull = false;
                }

                switch ($field.$category) {

                    case 'enum':
                        field.type = types.STRING;
                        var $source = Custom.app.Application.findMetadata($field.$prototype);
                        config.fields.push(field);
                        break;

                    case 'model':
                        var $model = Custom.app.Application.findMetadata($field.$prototype);

                        if (typeof $model !== 'object' || $model === null) {
                            break;
                        }
                        else if ($model.$embeddable) {

                            var fieldModel = this.findModel($field.$prototype);

                            if (typeof fieldModel !== 'function') {
                            }
                            else if (role.hasMany) {
                                config.associations.push({
                                    type: 'hasMany',
                                    model: fieldModel.modelName,
                                    name: $field.$name
                                });
                            }
                            else {
                                //field.type = fieldModel.modelName;
                                //config.fields.push(field);
                                config.associations.push({
                                    type: 'hasOne',
                                    model: fieldModel.modelName,
                                    name: $field.$name,
                                    associationKey: $field.$name
                                });

                                if ($field.$prototype === 'Text') {
                                    config.fields.push({
                                        name: '$' + $field.$name,
                                        persist: false,
                                        mapping: $field.$name,
                                        convert: function (v, record) {
                                            return Ext.custom.Adapter.toString(v || "<null>");
                                        }
                                    });
                                }
                            }
                        }
                        else {
                            field.type = types.STRING;
                            config.fields.push(field);
                        }
                        break;

                    case 'unit':
                        field.type = types.STRING;
                        var $prototype = Custom.app.Application.findMetadata($field.$prototype);
                        config.fields.push(field);
                        break;

                    case 'value':

                        switch ($field.$type) {

                            case 'boolean':
                                field.type = types.BOOLEAN;
                                break;

                            case 'string':
                                field.type = types.STRING;
                                break;

                            case 'integer':
                                field.type = types.INTEGER;
                                break;

                            case 'number':
                                field.type = types.NUMBER;
                                break;

                            case 'date':
                                field.type = types.DATE;
                                //field.dateFormat = '';
                                break;
                        }

                        /*if (typeof $field.$prototype === 'string') {
                            var $prototype = Custom.app.Application.findMetadata($field.$prototype);
                            var $validations = $prototype.$validations;
                            if (typeof $validations === 'object' && $validations != null) {
                                for (var i = 0; i < $validations.length; i++) {

                                    var $validation = $validations[i];

                                    var validation = { name: $field.$name, type: $validation.$type };

                                    switch ($validation.$type) {
                                        case 'presence':
                                            break;

                                        case 'length':
                                            break;

                                        case 'format':
                                            break;

                                        case 'inclusion':
                                            break;

                                        case 'exclusion':
                                            break;

                                        default:
                                            continue;
                                    }

                                    config.validations.push(validation);
                                }
                            }
                        }*/

                        config.fields.push(field);

                        break;
                }
            }

            if ($m.$embedded == true) {
            }
            else {

                var proxy = {
                    // Use for ajax proxy, since all the create, update and detroy requests will be all POST
                    // and for jsonp the api is the same, but the method is GET
                    type: 'ajax', // rest, jsonp or ajax.
                    //url: url,
                    /*api: {
                        create: url + '/create',
                        read: url + '/read',
                        update: url + '/update',
                        destroy: url + '/destroy'
                    },*/
                    buildUrl: function (request) {

                        var url = _baseUrl + '/Data/' + $m.$name;

                        if (typeof request.operation.id === 'string') {
                            url += '/' + request.operation.id;
                        }

                        switch (request.operation.action) {
                            case 'create':
                                return url + '/create';
                            case 'read':
                                return url + '/read';
                            case 'update':
                                return url + '/update';
                            case 'destroy':
                                return url + '/destroy';
                        }
                    },
                    headers: {
                        "Accept": "application/json"
                    },
                    listeners: {
                        exception: function (proxy, response, operation) {
                            Ext.MessageBox.show({
                                title: 'REMOTE EXCEPTION',
                                msg: operation.getError(),
                                icon: Ext.MessageBox.ERROR,
                                buttons: Ext.Msg.OK
                            });
                        }
                    },
                    reader: {
                        type: "json",
                        root: "data",
                        totalProperty: 'total',
                        successProperty: 'success',
                        messageProperty: 'message'
                    },
                    writer: Ext.create('Ext.data.writer.DeepPureJson', {
                        $m: $m,
                        type: 'json',
                        root: 'data',
                        allowSingle: false, // force data to be array
                        //dateFormat: "",
                        writeAllFields: false,
                        writeRecordId: true
                    })
                };

                Ext.merge(config, {
                    proxy: proxy
                });
            }

            model = Ext.define(name, config);

            return model;
        }

        function findMetadata(typeName) {
            var path = typeName.split('/');
            var $m = $metadata;
            for (var i = 0; i < path.length && $m !== null && typeof $m === 'object'; i++) {
                var name = path[i];
                $m = $m[name];
            }
            return $m;
        }

        function findModel(typeName) {

            var modelName = makeModelName(typeName);

            var model = Ext.ModelManager.getModel(modelName);

            if (model === null || typeof model === 'undefined') {

                var $m = Custom.app.Application.findMetadata(typeName);

                if ($m !== null && typeof $m === 'object') {

                    model = Custom.app.Application.defineModel(modelName, $m);
                }
            }

            return model;
        }

        function hashFields($m, $fields) {

            if ($m === null || typeof $m !== 'object') {
                return $fields;
            }

            if (typeof $m.$base === 'string') {
                hashFields(Custom.app.Application.findMetadata($m.$base), $fields);
            }

            if ($m !== null && typeof $m.$fields === 'object' && $m.$fields.length > 0) {

                for (var i = 0, count = $m.$fields.length; i < count; i++) {
                    var $field = $m.$fields[i];
                    $fields[$field.$name] = $field;
                }
            }

            return $fields;
        }

        function makeExtName(typeName) {
            return 'Ext.custom.data.' + typeName.replace(new RegExp('/', 'g'), '.');
        }

        function makeModelName(typeName) {
            return makeExtName(typeName) + '.Model';
        }

        function makeGridName(typeName, componentName) {
            return makeExtName(typeName) + '.' + componentName + '.Grid';
        }

        function makeFormName(typeName, componentName) {
            return makeExtName(typeName) + '.' + componentName + '.Form';
        }

        function makePanelName(typeName, componentName) {
            return makeExtName(typeName) + '.' + componentName + '.Panel';
        }

        function mergeMetadata($m) {
            Ext.Object.merge($metadata, $m);
        }

        function selectColumns($m, hash) {

            if (typeof $m !== 'object' || $m === null) {
                return;
            }

            if (typeof hash !== 'object' || hash === null) {
                hash = {};
            }

            if (typeof $m.$base === 'string') {
                selectColumns(Custom.app.Application.findMetadata($m.$base), hash);
            }

            if (typeof $m.$head === 'string') {
                var head = $m.$head.split('|');
                for (var i = 0; i < head.length; i++) {
                    var name = head[i];
                    hash[name] = true;
                }
            }

            var columns = [];

            var keys = Object.keys(hash);
            for (var i = 0; i < keys.length; i++) {
                var name = keys[i];
                if (hash[name] === true) {
                    columns.push(name);
                }
            }

            return columns;
        }

        function splitRole($role) {

            var role = {
                optional: true,
                embedded: false,
                identity: false,
                required: false,
                unique: false,
                readOnly: false,
                hasMany: false
            };

            switchValues($role, '|', {

                'Embedded': function () {
                    role.embedded = true;
                },

                'Identity': function () {
                    role.identity = true;
                },

                'Required': function () {
                    role.optional = false;
                    role.required = true;
                },

                'Unique': function () {
                    role.unique = true;
                },

                'Readonly': function () {
                    role.readOnly = true;
                },

                'HasMany': function () {
                    role.hasMany = true;
                },
            });

            return role;
        }

        // get the name spaces that are not clean (!dirty)
        function requires(path) {

            var segments = path.split('/');
            var result = [];

            var name = segments[0];
            var path = name;
            var $m = $metadata[name];

            for (var i = 1; i < segments.length; i++) {

                if ($m === null || typeof $m !== 'object') {
                    result.push(path);
                }
                else if ($m.$type !== 'name' && $m.$type !== 'area') {
                    break;
                }
                else if ($m.$dirty !== true) {
                    result.push(path);
                }

                name = segments[i];
                path = path + '/' + name;
            }

            return result;
        }



        function switchValues(value, separator, callback) {

            var values = value.split(separator);

            for (var i = 0; i < values.length; i++) {
                var fn = callback[values[i]];
                if (typeof fn === 'function') {
                    fn();
                }
            }
        }

        /**
        * class Ext.data.writer.DeepJson This class is used to write
         *        {link Ext.data.Model} data to the server in a JSON format.
         * 
         * It overrides the original Ext.data.writer.Json since the Json can not handle
         * hasMany association, it can only transform the outside part into Json, the
         * inside data will be omiited.
         * 
         * Yi Fang Reference:
            *     http://www.sencha.com/forum/showthread.php?141957-Saving-objects-that-are-linked-hasMany-relation-with-a-single-Store/page3     23 Mar 2012 6:00 AM
        *     http://www.sencha.com/forum/showthread.php?141957-Saving-objects-that-are-linked-hasMany-relation-with-a-single-Store/page5     13 Feb 2013 2:57 PM
        *     
        */
        Ext.define('Ext.data.writer.DeepJson', {
            extend: 'Ext.data.writer.Json',
            getRecordData: function (record, operation) {
                // Setup variables
                var me = this, i, association, childStore, data;

                data = me.callParent(arguments);

                // Iterate over all the hasMany associations
                for (i = 0; i < record.associations.length; i++) {
                    association = record.associations.get(i);
                    if (association.type == 'hasMany') {
                        data[association.name] = null;
                        childStore = record[association.storeName];

                        // Iterate over all the children in the current
                        // association
                        childStore.each(function (childRecord) {

                            if (!data[association.name]) {
                                data[association.name] = [];
                            }

                            // Recursively get the record data for
                            // children (depth first)
                            var childData = this.getRecordData.call(
                                    this, childRecord);

                            /*
                             * If the child was marked dirty or phantom
                             * it must be added. If there was data
                             * returned that was neither dirty or
                             * phantom, this means that the depth first
                             * recursion has detected that it has a
                             * child which is either dirty or phantom.
                             * For this child to be put into the
                             * prepared data, it's parents must be in
                             * place whether they were modified or not.
                             */
                            if (childRecord.dirty
                                    || childRecord.phantom
                                    || (childData != null)) {
                                data[association.name].push(childData);
                                record.setDirty();
                            }
                        }, me);

                        /*
                         * Iterate over all the removed records and add them to
                         * the preparedData. Set a flag on them to show that
                         * they are to be deleted
                         */
                        Ext.each(childStore.removed, function (
                                        removedChildRecord) {
                            // Set a flag here to identify removed
                            // records
                            removedChildRecord.set('forDeletion', true);
                            var removedChildData = this.getRecordData
                                    .call(this, removedChildRecord);
                            data[association.name]
                                    .push(removedChildData);
                            record.setDirty();
                        }, me);
                    }
                }

                // Only return data if it was dirty, new or marked for deletion.
                if (record.dirty || record.phantom || record.get('forDeletion')) {
                    return data;
                }
                return null;
            }
        });

        // convert arrays to objects usin property id as property name
        Ext.define('Ext.data.writer.DeepPureJson', {
            extend: 'Ext.data.writer.Json',
            getRecordData: function (record, operation) {
                // Setup variables
                var me = this, $m = this.$m, $fields = {}, i, association, childStore, data;

                data = me.callParent(arguments);

                var $fields = hashFields($m, $fields);

                // Iterate over all the hasMany associations
                for (i = 0; i < record.associations.length; i++) {

                    association = record.associations.get(i);

                    if (association.type == 'hasMany') {
                        data[association.name] = null;
                        childStore = record[association.storeName];

                        var $field = $fields[association.name];

                        if (typeof $field === 'object' && $field !== null && typeof $field.$id === 'string') {

                            // Iterate over all the children in the current
                            // association
                            childStore.each(function (childRecord) {

                                if (!data[association.name]) {
                                    data[association.name] = {};
                                }

                                // Recursively get the record data for
                                // children (depth first)
                                var childData = this.getRecordData.call(this, childRecord);

                                /*
                                 * If the child was marked dirty or phantom
                                 * it must be added. If there was data
                                 * returned that was neither dirty or
                                 * phantom, this means that the depth first
                                 * recursion has detected that it has a
                                 * child which is either dirty or phantom.
                                 * For this child to be put into the
                                 * prepared data, it's parents must be in
                                 * place whether they were modified or not.
                                 */

                                if (childRecord.dirty || childRecord.phantom || (childData != null)) {
                                    var key = childRecord.raw[$field.$id] || childData[$field.$id];
                                    data[association.name][key] = childData;
                                    record.setDirty();
                                }
                            }, me);

                            /*
                             * Iterate over all the removed records and add them to
                             * the preparedData. Set a flag on them to show that
                             * they are to be deleted
                             */
                            Ext.each(childStore.removed, function (removedChildRecord) {
                                // Set a flag here to identify removed
                                // records
                                removedChildRecord.set('forDeletion', true);
                                var key = removedChildRecord.raw[$field.$id];
                                if (!!key) {
                                    var removedChildData = this.getRecordData.call(this, removedChildRecord);
                                    data[association.name][key] = null;
                                    record.setDirty();
                                }
                            }, me);
                        }
                    }
                    else if (association.type === 'hasOne') {

                        var childRecord = record[association.instanceName];

                        if (typeof childRecord === 'object' && childRecord !== null) {

                            // Recursively get the record data for
                            // children (depth first)
                            //var childData = childRecord.getData(true);// this.getRecordData.call(this, childRecord);

                            var changes = childRecord.getChanges();

                            var changesKeys = Object.keys(changes);

                            if (changesKeys.length > 0) {
                                data[association.name] = Ext.merge({}, changes);
                                record.setDirty();
                            }
                        }
                    }
                }

                // Only return data if it was dirty, new or marked for deletion.
                if (record.dirty || record.phantom || record.get('forDeletion')) {
                    return data;
                }

                return null;
            }
        });

        return {
            name: 'Customary',
            extend: 'Ext.app.Application',
            requires: [
                'Ext.container.Viewport',
            ],
            uses: [
                'Ext.custom.Adapter',
                'Ext.custom.Droplet'
            ],
            statics: {
                asyncMetadata: asyncMetadata,
                asyncModel: asyncModel,
                collectFields: collectFields,
                configGrid: configGrid,
                defineModel: defineModel,
                findMetadata: findMetadata,
                findModel: findModel,
                selectColumns: selectColumns,
                splitRole: splitRole
            },
            culture: 'en',
            dirty: false,
            appFolder: '/Scripts/Ext/custom',
            appProperty: 'current',
            //models: ['Post', 'Comment'],
            controllers: ['Drops'/*, 'Comments'*/],
            launch: function () {

                // Apply a set of config properties to the singleton
                /*Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {
                    //maxWidth: 600,
                    //minWidth: 300,
                    //mouseOffset: [50, 50],
                    //showDelay: 50      // Show 50ms after entering target
                });*/

                var directory = Ext.create('Ext.custom.data.Directory');

                this.centerPanel = Ext.create('Ext.panel.Panel', {
                    region: 'center',
                    bodyStyle: frameStyle, // background color like frame
                    header: true,
                    items: [],
                    flex: 4,
                    border: false,
                    layout: 'fit',
                    title: 'Empty View'
                });

                Ext.create('Ext.container.Viewport', {
                    layout: 'border',
                    bodyStyle: frameStyle, // background color like frame
                    items: [
                        /*{
                            region: 'north',
                            xtype: 'container',
                            bodyStyle: frameStyle, // background color like frame
                            html: 'Html.Partial("~/Areas/Data/Views/Name/Header.cshtml")',
                            autoHeight: true,
                            border: false,
                            margins: '0 0 5 0'
                        },*/
                        directory.initComponent({
                            activeTab: 0,
                            bodyStyle: frameStyle, // background color like frame
                            bodyBorder: false,
                            border: false,
                            collapsible: true,
                            /*tbar: {
                                xtype: 'toolbar',
                                dock: 'top',
                                layout: {
                                    align: 'center'
                                },
                                items: [
                                    {
                                        text: 'Data Dictionary',
                                        xtype: 'text'
                                    }
                                ],
                                //margin: '6 0 3 0',
                                //ui: 'header'
                            },*/
                            flex: 3,
                            header: false,
                            layout: 'fit',
                            listeners: {
                                select: {
                                    fn: function (directory, record, selModel, selections) {
                                        if (record !== null && typeof record === 'object') {

                                            if (typeof record.typeName !== 'string') {
                                                this.centerPanel.removeAll();
                                                this.centerPanel.doLayout();
                                                this.centerPanel.setTitle('Empty View');
                                            }
                                            else {
                                                var title = record.typeName + '/' + record.id;
                                                this.centerPanel.removeAll();
                                                this.centerPanel.setTitle(title + ' (loading...)');
                                                this.centerPanel.mask('Loading... Please wait', 'loading');
                                                Ext.custom.Droplet.asyncCreate(record.typeName, false, function (droplet) {
                                                    this.centerPanel.add(droplet.initComponent({
                                                    }));
                                                    this.centerPanel.doLayout();

                                                    droplet.load(record.id, function () {
                                                        this.centerPanel.setTitle(title);
                                                        this.centerPanel.unmask();
                                                    }, this);
                                                    //droplet.asyncLoad(record.id);
                                                }, this);
                                            }

                                        }
                                        else {

                                        }
                                    },
                                    scope: this
                                }
                                /*add: {
                                    fn: function (tabPanel, component, index, eOpts) {
                                        if (typeof tabPanel.title !== 'string') {
                                            tabPanel.setTitle(component.title);
                                        }
                                    },
                                    scope: this
                                },
                                tabchange: {
                                    fn: this.onViewTabChange,
                                    scope: this
                                }*/
                            },
                            margins: '26 0 0 5',
                            region: 'west',
                            split: true
                        }),
                        this.centerPanel,
                        {
                            bodyStyle: frameStyle, // background color like frame
                            bodyBorder: false,
                            border: false,
                            collapsible: true,
                            flex: 1,
                            header: false,
                            items: [
                            ],
                            layout: 'fit',
                            listeners: {
                                added: {
                                    fn: function (component, container, pos, eOpts) {
                                        Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {
                                            closable: true,
                                            renderTo: component
                                            //maxWidth: 600,
                                            //minWidth: 300,
                                            //mouseOffset: [50, 50],
                                            //showDelay: 50      // Show 50ms after entering target
                                        });
                                        return true;
                                    },
                                    scope: this
                                },
                                boxready: {
                                    fn: function (component, width, height, eOpts) {
                                        console.log('boxready');
                                        Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {
                                            closable: true,
                                            target: component.el,
                                            trackMouse: true,
                                            listeners: {              // Change content dynamically depending on which element triggered the show.
                                                beforeshow: function updateTipBody(tip) {
                                                    tip.update('Over company');// "' + view.getRecord(tip.triggerElement).get('company') + '"');
                                                }
                                            }
                                            //maxWidth: 600,
                                            //minWidth: 300,
                                            //mouseOffset: [50, 50],
                                            //showDelay: 50      // Show 50ms after entering target
                                        });
                                        return true;
                                    },
                                    scope: this
                                }
                            },
                            region: 'east',
                            split: true,
                            title: 'Help',
                            xtype: 'panel'
                        }
                    ]
                });
                window.onbeforeunload = function () {
                    if (Customary.current.dirty) {
                        return "You have made changes on this page that you have not yet confirmed. If you navigate away from this page you will lose your unsaved changes";
                    }
                };

                if (Ext.supports.History) { // <- this prevents the firing off of the event
                    Ext.History.init()
                    Ext.History.on('change', this.onHistoryChange);
                    /*Ext.custom.Adapter.subscribe('Customary.view.Directory.selectionchange', function (path) {
                        Ext.History.add(path)
                    });
                    Ext.custom.Adapter.subscribe('Customary.view.Index.selectionchange', function (id) {
                        Ext.History.add(path + '/' + id)
                    });*/
                }
                else {
                    /*Ext.custom.Adapter.subscribe('Customary.view.Index.selectionchange', function (id) {
                        this.onHistoryChange();
                    });*/

                    this.onHistoryChange();
                }
            },

            onHistoryChange: function (id) {

                var token = Ext.History.getToken();

                var path = token.split('/');

                if (typeof token === 'string') {

                    if (guidRegex.test(token)) {
                        console.log('token accepted');
                        this.onHistoryChange(token);
                    }
                    else {
                        //alert("Invalid token");
                        this.onHistoryChange();
                    }
                }
                else {
                }
            }
        }
    });
</script>

<script type="text/javascript">
    Ext.application('Custom.app.Application');
</script>

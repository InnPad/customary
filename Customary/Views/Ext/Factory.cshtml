<script type="text/javascript">
    Ext.define('Ext.custom.Factory', function () {

        var _baseUrl = 'http://data.customary.com';

        function makeExtName(typeName) {
            return 'Ext.custom.data.' + typeName.replace(new RegExp('/', 'g'), '.');
        }

        function makeModelName(typeName) {
            return makeExtName(typeName) + '.Model';
        }

        function makeGridName(typeName, componentName) {
            return makeExtName(typeName) + '.' + componentName + '.Grid';
        }

        function makeFormName(typeName, componentName) {
            return makeExtName(typeName) + '.' + componentName + '.Form';
        }

        function makePanelName(typeName, componentName) {
            return makeExtName(typeName) + '.' + componentName + '.Panel';
        }

        function switchValues(value, separator, callback) {

            var values = value.split(separator);

            for (var i = 0; i < values.length; i++) {
                var fn = callback[values[i]];
                if (typeof fn === 'function') {
                    fn();
                }
            }
        }

        function splitRole($role) {

            var role = {
                optional: true,
                embedded: false,
                identity: false,
                required: false,
                unique: false,
                readOnly: false,
                hasMany: false
            };

            switchValues($role, '|', {

                'Embedded': function () {
                    role.embedded = true;
                },

                'Identity': function () {
                    role.identity = true;
                },

                'Required': function () {
                    role.optional = false;
                    role.required = true;
                },

                'Unique': function () {
                    role.unique = true;
                },

                'Readonly': function () {
                    role.readOnly = true;
                },

                'HasMany': function () {
                    role.hasMany = true;
                },
            });

            return role;
        }

        var $metadata = {
        };

        // get the name spaces that are not clean (!dirty)
        function requires(path) {

            var segments = path.split('/');
            var result = [];

            var name = segments[0];
            var path = name;
            var $m = $metadata[name];

            for (var i = 1; i < segments.length; i++) {

                if ($m === null || typeof $m !== 'object') {
                    result.push(path);
                }
                else if ($m.$type !== 'name' && $m.$type !== 'area') {
                    break;
                }
                else if ($m.$dirty !== true) {
                    result.push(path);
                }

                name = segments[i];
                path = path + '/' + name;
            }

            return result;
        }

        function hashFields($m, $fields) {

            if ($m === null || typeof $m !== 'object') {
                return $fields;
            }

            if (typeof $m.$base === 'string') {
                hashFields(Ext.custom.Factory.findMetadata($m.$base), $fields);
            }

            if ($m !== null && typeof $m.$fields === 'object' && $m.$fields.length > 0) {

                for (var i = 0, count = $m.$fields.length; i < count; i++) {
                    var $field = $m.$fields[i];
                    $fields[$field.$name] = $field;
                }
            }

            return $fields;
        }

        // copied fromDroplet
        function collectFields($m, $fields) {

            if ($m === null || typeof $m !== 'object') {
                return $fields;
            }

            if (typeof $m.$base === 'string') {
                collectFields(Ext.custom.Factory.findMetadata($m.$base), $fields);
            }

            if ($m !== null && typeof $m.$fields === 'object' && $m.$fields.length > 0) {
                $fields.push.apply($fields, $m.$fields);
            }

            return $fields;
        }

        /**
        * class Ext.data.writer.DeepJson This class is used to write
         *        {link Ext.data.Model} data to the server in a JSON format.
         * 
         * It overrides the original Ext.data.writer.Json since the Json can not handle
         * hasMany association, it can only transform the outside part into Json, the
         * inside data will be omiited.
         * 
         * Yi Fang Reference:
            *     http://www.sencha.com/forum/showthread.php?141957-Saving-objects-that-are-linked-hasMany-relation-with-a-single-Store/page3     23 Mar 2012 6:00 AM
        *     http://www.sencha.com/forum/showthread.php?141957-Saving-objects-that-are-linked-hasMany-relation-with-a-single-Store/page5     13 Feb 2013 2:57 PM
        *     
        */
        Ext.define('Ext.data.writer.DeepJson', {
            extend: 'Ext.data.writer.Json',
            getRecordData: function (record, operation) {
                // Setup variables
                var me = this, i, association, childStore, data;

                data = me.callParent(arguments);

                // Iterate over all the hasMany associations
                for (i = 0; i < record.associations.length; i++) {
                    association = record.associations.get(i);
                    if (association.type == 'hasMany') {
                        data[association.name] = null;
                        childStore = record[association.storeName];

                        // Iterate over all the children in the current
                        // association
                        childStore.each(function (childRecord) {

                            if (!data[association.name]) {
                                data[association.name] = [];
                            }

                            // Recursively get the record data for
                            // children (depth first)
                            var childData = this.getRecordData.call(
                                    this, childRecord);

                            /*
                             * If the child was marked dirty or phantom
                             * it must be added. If there was data
                             * returned that was neither dirty or
                             * phantom, this means that the depth first
                             * recursion has detected that it has a
                             * child which is either dirty or phantom.
                             * For this child to be put into the
                             * prepared data, it's parents must be in
                             * place whether they were modified or not.
                             */
                            if (childRecord.dirty
                                    || childRecord.phantom
                                    || (childData != null)) {
                                data[association.name].push(childData);
                                record.setDirty();
                            }
                        }, me);

                        /*
                         * Iterate over all the removed records and add them to
                         * the preparedData. Set a flag on them to show that
                         * they are to be deleted
                         */
                        Ext.each(childStore.removed, function (
                                        removedChildRecord) {
                            // Set a flag here to identify removed
                            // records
                            removedChildRecord.set('forDeletion', true);
                            var removedChildData = this.getRecordData
                                    .call(this, removedChildRecord);
                            data[association.name]
                                    .push(removedChildData);
                            record.setDirty();
                        }, me);
                    }
                }

                // Only return data if it was dirty, new or marked for deletion.
                if (record.dirty || record.phantom || record.get('forDeletion')) {
                    return data;
                }
                return null;
            }
        });

        // convert arrays to objects usin property id as property name
        Ext.define('Ext.data.writer.DeepPureJson', {
            extend: 'Ext.data.writer.Json',
            getRecordData: function (record, operation) {
                // Setup variables
                var me = this, $m = this.$m, $fields = {}, i, association, childStore, data;

                data = me.callParent(arguments);

                var $fields = hashFields($m, $fields);

                // Iterate over all the hasMany associations
                for (i = 0; i < record.associations.length; i++) {

                    association = record.associations.get(i);

                    if (association.type == 'hasMany') {
                        data[association.name] = null;
                        childStore = record[association.storeName];

                        var $field = $fields[association.name];

                        if (typeof $field === 'object' && $field !== null && typeof $field.$id === 'string') {

                            // Iterate over all the children in the current
                            // association
                            childStore.each(function (childRecord) {

                                if (!data[association.name]) {
                                    data[association.name] = {};
                                }

                                // Recursively get the record data for
                                // children (depth first)
                                var childData = this.getRecordData.call(this, childRecord);

                                /*
                                 * If the child was marked dirty or phantom
                                 * it must be added. If there was data
                                 * returned that was neither dirty or
                                 * phantom, this means that the depth first
                                 * recursion has detected that it has a
                                 * child which is either dirty or phantom.
                                 * For this child to be put into the
                                 * prepared data, it's parents must be in
                                 * place whether they were modified or not.
                                 */

                                if (childRecord.dirty || childRecord.phantom || (childData != null)) {
                                    var key = childRecord.raw[$field.$id] || childData[$field.$id];
                                    data[association.name][key] = childData;
                                    record.setDirty();
                                }
                            }, me);

                            /*
                             * Iterate over all the removed records and add them to
                             * the preparedData. Set a flag on them to show that
                             * they are to be deleted
                             */
                            Ext.each(childStore.removed, function (removedChildRecord) {
                                // Set a flag here to identify removed
                                // records
                                removedChildRecord.set('forDeletion', true);
                                var key = removedChildRecord.raw[$field.$id];
                                if (!!key) {
                                    var removedChildData = this.getRecordData.call(this, removedChildRecord);
                                    data[association.name][key] = null;
                                    record.setDirty();
                                }
                            }, me);
                        }
                    }
                    else if (association.type === 'hasOne') {

                        var childRecord = record[association.instanceName];

                        if (typeof childRecord === 'object' && childRecord !== null) {

                            // Recursively get the record data for
                            // children (depth first)
                            //var childData = childRecord.getData(true);// this.getRecordData.call(this, childRecord);

                            var changes = childRecord.getChanges();

                            var changesKeys = Object.keys(changes);

                            if (changesKeys.length > 0) {
                                data[association.name] = Ext.merge({}, changes);
                                record.setDirty();
                            }
                        }
                    }
                }

                // Only return data if it was dirty, new or marked for deletion.
                if (record.dirty || record.phantom || record.get('forDeletion')) {
                    return data;
                }

                return null;
            }
        });

        return {
            singleton: true,

            requires: [
                'Ext.custom.Adapter',
                'Ext.custom.Droplet'
            ],

            constructor: function () {
                this.baseUrl = 'http://data.customary.com';
            },

            splitRole: splitRole,

            findMetadata: function (typeName) {
                var path = typeName.split('/');
                var $m = $metadata;
                for (var i = 0; i < path.length && $m !== null && typeof $m === 'object'; i++) {
                    var name = path[i];
                    $m = $m[name];
                }
                return $m;
            },

            mergeMetadata: function ($m) {
                Ext.Object.merge($metadata, $m);
            },

            asyncMetadata: function (typeName, callback) {

                var $m = this.findMetadata(typeName);

                if ($m !== null && typeof $m === 'object') {
                    callback($m);
                }
                else {

                    var jsonData = {
                        requires: requires(typeName)
                    };

                    Ext.Ajax.request({
                        url: this.baseUrl + '/Data/' + typeName + '/$metadata',
                        method: 'POST',
                        jsonData: jsonData,
                        /*params: {
                            id: '00000000-0000-0000-0000-000000000001'
                        },*/
                        success: function (response, options) {
                            var text = response.responseText;
                            var json = Ext.JSON.decode(text, true);
                            if (json == null || typeof json !== 'object') {
                                alert(text);
                            }
                            else if (json.success === true && typeof json.data === 'object') {

                                this.mergeMetadata(json.data);

                                $m = this.findMetadata(typeName);

                                if ($m !== null && typeof $m === 'object') {
                                    callback.call(this, $m);
                                }

                            } else if (typeof json.message === 'string') {
                                alert(json.message);
                            }
                        },
                        failure: function (response, options) {
                        },
                        scope: this
                    });
                }
            },

            findModel: function (typeName) {

                var modelName = makeModelName(typeName);

                var model = Ext.ModelManager.getModel(modelName);

                if (model === null || typeof model === 'undefined') {

                    var $m = this.findMetadata(typeName);

                    if ($m !== null && typeof $m === 'object') {

                        model = this.defineModel(modelName, $m);
                    }
                }

                return model;
            },

            defineModel: function (name, $m) {

                var extend = 'Ext.data.Model';

                if (typeof $m.$extend === 'string') {
                    var extendModel = this.findModel($m.$extend);
                    //extend = makeModelName($m.$extend);
                }

                var config = {
                    extend: extend,
                    idProperty: 'Id',
                    fields: [],
                    associations: [],
                    validations: []
                };

                if (typeof $m.$belongsTo === 'string') {
                    config['belongsTo'] = makeModelName($m.$belongsTo);
                    /*var belongsTo = this.findModel($m.$belongsTo);
                    if (belongsTo) {
                        config['belongsTo'] = belongsTo.modelName;
                    }*/
                }

                var $fields = collectFields($m, []);

                var types = Ext.data.Types; // allow shorthand type access

                for (var i = 0; i < $fields.length; i++) {
                    var $field = $fields[i];
                    var role = splitRole($field.$role);
                    var field = { name: $field.$name };

                    if (role.required) {
                        field.useNull = false;
                    }

                    switch ($field.$category) {

                        case 'enum':
                            field.type = types.STRING;
                            var $source = this.findMetadata($field.$prototype);
                            config.fields.push(field);
                            break;

                        case 'model':
                            var $model = this.findMetadata($field.$prototype);

                            if (typeof $model !== 'object' || $model === null) {
                                break;
                            }
                            else if ($model.$embeddable) {

                                var fieldModel = this.findModel($field.$prototype);

                                if (typeof fieldModel !== 'function') {
                                }
                                else if (role.hasMany) {
                                    config.associations.push({
                                        type: 'hasMany',
                                        model: fieldModel.modelName,
                                        name: $field.$name
                                    });
                                }
                                else {
                                    //field.type = fieldModel.modelName;
                                    //config.fields.push(field);
                                    config.associations.push({
                                        type: 'hasOne',
                                        model: fieldModel.modelName,
                                        name: $field.$name,
                                        associationKey: $field.$name
                                    });

                                    if ($field.$prototype === 'Text') {
                                        config.fields.push({
                                            name: '$' + $field.$name,
                                            persist: false,
                                            mapping: $field.$name,
                                            convert: function (v, record) {
                                                return Ext.custom.Adapter.toString(v || "<null>");
                                            }
                                        });
                                    }
                                }
                            }
                            else {
                                field.type = types.STRING;
                                config.fields.push(field);
                            }
                            break;

                        case 'unit':
                            field.type = types.STRING;
                            var $prototype = this.findMetadata($field.$prototype);
                            config.fields.push(field);
                            break;

                        case 'value':

                            switch ($field.$type) {

                                case 'boolean':
                                    field.type = types.BOOLEAN;
                                    break;

                                case 'string':
                                    field.type = types.STRING;
                                    break;

                                case 'integer':
                                    field.type = types.INTEGER;
                                    break;

                                case 'number':
                                    field.type = types.NUMBER;
                                    break;

                                case 'date':
                                    field.type = types.DATE;
                                    //field.dateFormat = '';
                                    break;
                            }

                            /*if (typeof $field.$prototype === 'string') {
                                var $prototype = this.findMetadata($field.$prototype);
                                var $validations = $prototype.$validations;
                                if (typeof $validations === 'object' && $validations != null) {
                                    for (var i = 0; i < $validations.length; i++) {

                                        var $validation = $validations[i];

                                        var validation = { name: $field.$name, type: $validation.$type };

                                        switch ($validation.$type) {
                                            case 'presence':
                                                break;

                                            case 'length':
                                                break;

                                            case 'format':
                                                break;

                                            case 'inclusion':
                                                break;

                                            case 'exclusion':
                                                break;

                                            default:
                                                continue;
                                        }

                                        config.validations.push(validation);
                                    }
                                }
                            }*/

                            config.fields.push(field);

                            break;
                    }
                }

                if ($m.$embedded == true) {
                }
                else {

                    var proxy = {
                        // Use for ajax proxy, since all the create, update and detroy requests will be all POST
                        // and for jsonp the api is the same, but the method is GET
                        type: 'ajax', // rest, jsonp or ajax.
                        //url: url,
                        /*api: {
                            create: url + '/create',
                            read: url + '/read',
                            update: url + '/update',
                            destroy: url + '/destroy'
                        },*/
                        buildUrl: function (request) {

                            var url = _baseUrl + '/Data/' + $m.$name;

                            if (typeof request.operation.id === 'string') {
                                url += '/' + request.operation.id;
                            }

                            switch (request.operation.action) {
                                case 'create':
                                    return url + '/create';
                                case 'read':
                                    return url + '/read';
                                case 'update':
                                    return url + '/update';
                                case 'destroy':
                                    return url + '/destroy';
                            }
                        },
                        headers: {
                            "Accept": "application/json"
                        },
                        listeners: {
                            exception: function (proxy, response, operation) {
                                Ext.MessageBox.show({
                                    title: 'REMOTE EXCEPTION',
                                    msg: operation.getError(),
                                    icon: Ext.MessageBox.ERROR,
                                    buttons: Ext.Msg.OK
                                });
                            }
                        },
                        reader: {
                            type: "json",
                            root: "data",
                            totalProperty: 'total',
                            successProperty: 'success',
                            messageProperty: 'message'
                        },
                        writer: Ext.create('Ext.data.writer.DeepPureJson', {
                            $m: $m,
                            type: 'json',
                            root: 'data',
                            allowSingle: false, // force data to be array
                            //dateFormat: "",
                            writeAllFields: false,
                            writeRecordId: true
                        })
                    };

                    Ext.merge(config, {
                        proxy: proxy
                    });
                }

                model = Ext.define(name, config);

                return model;
            },

            asyncModel: function (typeName, callback) {

                var modelName = makeModelName(typeName);

                var model = Ext.ModelManager.getModel(modelName);

                if (model !== null && typeof model === 'function') {
                    callback(modelName, model);
                    return;
                }

                this.asyncMetadata(typeName, function ($m) {

                    model = this.defineModel(modelName, $m);

                    callback(modelName, model);
                });
            },

            createIndexGrid: function (typeName, model, $m) {

                var gridName = makeGridName(typeName, 'index');

                var config = {
                };

                var grid = Ext.create(gridName, config);

                return grid;
            }
        };
    });
</script>
